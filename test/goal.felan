void :: struct {};

u64 :: struct {
  _ : value64;
};

Syscall :: enum {
  READ,
  WRITE,
  OPEN,
  CLOSE,
  EXIT,
};

StdFile :: enum {
  IN,
  OUT,
  ERR,
};

syscall :: fasm (
  sysc : Syscall,
  arg0 : u64 = undefined,
  arg1 : u64 = undefined,
  arg2 : u64 = undefined,
  arg3 : u64 = undefined,
  arg4 : u64 = undefined,
  arg5 : u64 = undefined,
  arg6 : u64 = undefined,
) -> void {
  syscall
};

operator ltr order2 infix + :: fasm (a : u64, b : u64) -> u64 {
  add_i64
};

operator ltr order2 infix - :: fasm (a : u64, b : u64) -> u64 {
  sub_i64
};

operator ltr order3 infix * :: fasm (a : u64, b : u64) -> u64 {
  mul_u64
};

operator ltr order3 infix / :: fasm (a : u64, b : u64) -> u64 {
  div_u64
};

operator ltr order3 infix % :: fasm (a : u64, b : u64) -> u64 {
  rem_u64
};

operator ltr order4 prefix + :: fasm (a : u64) -> u64 {
  // nothing
};

operator ltr order4 prefix - :: fasm (a : u64, b : u64) -> u64 {
  negu64
};

operator ltr order5 prefix ** :: (a : u64, b : u64) -> u64 {
  return pow(a,b);
};

assignToAddr64 :: fasm (addr : value64, b : value64) -> void {
  pop64
};

// self assign can't be overloaded because of pass to function itself
operator rtl order1 infix = :: (a : u64, b : value64) -> u64 {
  assignToAddr64(@addressOf(a),b);
  return a;
};

exit :: (code : u64) -> void {
  syscall(Syscall.EXIT, code);
};

// a comment
main :: () -> void {
  a : u64 = 2; // some comment
  exit(a + 4);
};

